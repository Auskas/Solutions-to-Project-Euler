#
# Solution to Project Euler Problem 3 Largest prime factor
# Copyright (c) Auskas. All rights reserved.
#
# https://github.com/Auskas/Solutions-to-Project-Euler
# Two slightly different algorithms are used in the module to solve the problem.
# The first approach uses a list of prime numbers generated by the Sieve of Eratosphenes.
# The second algorithm is a bit faster. Instead of creating an enormous list of primes it creates a list of primes in the interval from 2 to 1002.
# If the primes are out, it creates another list in the following interval etc.

import time

# The well-known Sieve of Eratosphenes is used to find all prime numbers below N. The algorithm is a bit modified:
# We exclude all even numbers from the list from the beginning apart from 2. All other prime numbers are always odd.
# Another tweak is we can stop incrementing the number i when the square of i reaches the number N.
# Inside the function a set is used instead of a list. Partially because set operations are faster than the list ones.
def eratosphenes_sieve(N):
    """Returns a sorted list of prime numbers below N."""
    primes = set([i for i in range(3,N + 1,2)]) # Creates a set of all odd numbers from 3 to N. 
    primes.add(2) # 2 is the only even prime number. We must add it to the set.
    i = 3
    while i ** 2 < N:  
        m = N // i # This value determines the biggest multiple of i below N.
        for j in range(i ** 2, (m * i) + 1, i): # Checks all the multiples of j from j ** 2 to the highest possible multiple below N.
            if j in primes:
                primes.remove(j)
        i += 2 # We only need to check odd numbers that is why we always increment i by 2 (the initial value is 3).
    primes = list(primes)
    primes.sort()
    return primes

# Using the sorted list of all prime numbers from 2 to the square root of N we divide the number N by 2 while it is evenly divisible. Then we move to the next prime number and repeat the process.
def largest_prime_factor(N,biggest_prime=0):
    """Returns the biggest prime factor of the number N."""
    primes = eratosphenes_sieve(int(N ** (1/2) + 1)) # The upper limit is the square root of the number N. It is known that we don't need to seek for any prime factors above that limit
    while N > 1:
        for elem in primes:
            while N % elem == 0:
                N //= elem
                if N == 1:
                    return elem

# The second approach is to form a list of prime numbers in the interval from start to end.               
def prime_numbers(start, end):
    """Returns a list of prime numbers in the interval from start to end."""
    prime_numbers = list(i for i in range(start,end + 1)) # This list contains all numbers from start to end.
    div = start # This variable is used to check all the prime dividers.
    while div ** 2 < end:   # This condition checks if the power of two of the current prime divider is lower than the biggest number in the interval.
        m = end // div      
        for j in range(div ** 2, (m * div) + 1, div):
            if j in prime_numbers:
                prime_numbers.remove(j)
        if div % 2 == 0:
            div += 1
        else:
            div += 2
    return prime_numbers

# The alternative function gets a list of prime numbers from 2 to 1002 and divides the number N by the primes starting with 2 while it is evenly divisible.
# When the list of primes is out of range, another list of prime numbers is generated in the interval from 1003 to 2003 and so on.
def largest_prime_factor_alt(N):
    """Returns the biggest prime factor of the number N."""
    prime = 2 # This is the lowest prime number that can be a factor of the given number N.
    start = 2 
    while N != 1:   # This cycle is executed until the final prime factor is found.
        end = start + 1000  
        while end < N + 1000:   # This cycle is executed while there are proper prime dividers in the current interval.
            found = False
            prime_numbers_in_interval = prime_numbers(start, end)
            for elem in prime_numbers_in_interval:
                if N % elem == 0:
                    N /= elem
                    prime = elem
                    found = True
                    break
            if found:
                start = 2
                break
            else:
                start = end + 1
                end = start + 1000
    return prime
    
N = 600851475143
start = time.perf_counter()
print("The largest prime factor of the number", N, "is", largest_prime_factor(N))
print("The execution time is", time.perf_counter() - start,"seconds.")
start = time.perf_counter()
print("The largest prime factor of the number", N, "is", largest_prime_factor_alt(N))
print("The execution time is", time.perf_counter() - start,"seconds.")

            
        
